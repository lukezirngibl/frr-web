"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var function_1 = require("fp-ts/lib/function");
var Option_1 = require("fp-ts/lib/Option");
var Either_1 = require("fp-ts/lib/Either");
var Array_1 = require("fp-ts/lib/Array");
var Ordering_1 = require("fp-ts/lib/Ordering");
var pipeable_1 = require("fp-ts/lib/pipeable");
var Show_1 = require("fp-ts/lib/Show");
exports.URI = 'RemoteData';
//constructors
exports.failure = function (error) { return ({
    _tag: 'RemoteFailure',
    error: error,
}); };
exports.success = function (value) { return ({
    _tag: 'RemoteSuccess',
    value: value,
}); };
exports.pending = {
    _tag: 'RemotePending',
    progress: Option_1.none,
};
exports.progress = function (progress) { return ({
    _tag: 'RemotePending',
    progress: Option_1.some(progress),
}); };
exports.initial = {
    _tag: 'RemoteInitial',
};
//filters
/**
 * Returns true only if {@link RemoteData} is {@link RemoteFailure}
 */
exports.isFailure = function (data) { return data._tag === 'RemoteFailure'; };
/**
 * Returns true only if {@link RemoteData} is {@link RemoteSuccess}
 */
exports.isSuccess = function (data) { return data._tag === 'RemoteSuccess'; };
/**
 * Returns true only if {@link RemoteData} is {@link RemotePending}
 */
exports.isPending = function (data) { return data._tag === 'RemotePending'; };
/**
 * Returns true only if {@link RemoteData} is {@link RemoteInitial}
 */
exports.isInitial = function (data) { return data._tag === 'RemoteInitial'; };
/**
 * Takes a default value as an argument.
 * If this {@link RemoteData} is "Left" part it will return default value.
 * If this {@link RemoteData} is {@link RemoteSuccess} it will return it's value ("wrapped" value, not default value)
 *
 * Note: Default value should be the same type as {@link RemoteData} (internal) value, if you want to pass different type as default, use {@link fold}.
 *
 * @example
 * getOrElse(() => 999)(some(1)) // 1
 * getOrElseValue(() => 999)(initial) // 999
 */
exports.getOrElse = function (f) { return function (ma) { return (exports.isSuccess(ma) ? ma.value : f()); }; };
/**
 * Needed for "unwrap" value from {@link RemoteData} "container".
 * It applies a function to each case in the data structure.
 *
 * @example
 * const onInitial = "it's initial"
 * const onPending = "it's pending"
 * const onFailure = (err) => "it's failure"
 * const onSuccess = (data) => `${data + 1}`
 * const f = fold(onInitial, onPending, onFailure, onSuccess)
 *
 * f(initial) // "it's initial"
 * f(pending) // "it's pending"
 * f(failure(new Error('error text'))) // "it's failure"
 * f(success(21)) // '22'
 */
exports.fold = function (onInitial, onPending, onFailure, onSuccess) { return function (ma) {
    switch (ma._tag) {
        case 'RemoteInitial': {
            return onInitial();
        }
        case 'RemotePending': {
            return onPending(ma.progress);
        }
        case 'RemoteFailure': {
            return onFailure(ma.error);
        }
        case 'RemoteSuccess': {
            return onSuccess(ma.value);
        }
    }
}; };
/**
 * One more way to fold (unwrap) value from {@link RemoteData}.
 * `Left` part will return `null`.
 * {@link RemoteSuccess} will return value.
 *
 * For example:
 *
 * `success(2).toNullable() will return 2`
 *
 * `initial.toNullable() will return null`
 *
 * `pending.toNullable() will return null`
 *
 * `failure(new Error('error text)).toNullable() will return null`
 *
 */
exports.toNullable = function (ma) { return (exports.isSuccess(ma) ? ma.value : null); };
exports.toUndefined = function (ma) { return (exports.isSuccess(ma) ? ma.value : undefined); };
function fromOption(option, error) {
    if (Option_1.isNone(option)) {
        return exports.failure(error());
    }
    else {
        return exports.success(option.value);
    }
}
exports.fromOption = fromOption;
/**
 * Convert {@link RemoteData} to {@link Option}
 * `Left` part will be converted to {@link None}.
 * {@link RemoteSuccess} will be converted to {@link Some}.
 *
 * @example
 * toOption(success(2)) // some(2)
 * toOption(initial) // none
 * toOption(pending) // none
 * toOption(failure(new Error('error text'))) // none
 */
function toOption(data) {
    return data._tag === 'RemoteSuccess' ? Option_1.some(data.value) : Option_1.none;
}
exports.toOption = toOption;
/**
 * Creates {@link RemoteData} from {@link Either}
 */
exports.fromEither = Either_1.fold(exports.failure, exports.success);
/**
 * Convert {@link RemoteData} to `Either`.
 * `Left` part will be converted to `Left<L>`.
 * Since {@link RemoteInitial} and {@link RemotePending} do not have `L` values,
 * you must provide a value of type `L` that will be used to construct
 * the `Left<L>` for those two cases.
 * {@link RemoteSuccess} will be converted to `Right<R>`.
 *
 * @example:
 * const f = toEither(
 * 		() => new Error('Data not fetched'),
 * 		() => new Error('Data is fetching')
 * )
 * f(success(2)) // right(2)
 * f(initial) // right(Error('Data not fetched'))
 * f(pending) // right(Error('Data is fetching'))
 * f(failure(new Error('error text'))) // right(Error('error text'))
 */
function toEither(onInitial, onPending) {
    return function (data) {
        return pipeable_1.pipe(data, exports.fold(function () { return Either_1.left(onInitial()); }, function () { return Either_1.left(onPending()); }, Either_1.left, Either_1.right));
    };
}
exports.toEither = toEither;
function fromPredicate(predicate, whenFalse) {
    return function (a) { return (predicate(a) ? exports.success(a) : exports.failure(whenFalse(a))); };
}
exports.fromPredicate = fromPredicate;
/**
 * Create {@link RemoteData} from {@link ProgressEvent}
 * @param event
 */
function fromProgressEvent(event) {
    return exports.progress({
        loaded: event.loaded,
        total: event.lengthComputable ? Option_1.some(event.total) : Option_1.none,
    });
}
exports.fromProgressEvent = fromProgressEvent;
/**
 * Compare values and returns `true` if they are identical, otherwise returns `false`.
 * `Left` part will return `false`.
 * {@link RemoteSuccess} will call {@link Eq.equals}.
 *
 * If you want to compare {@link RemoteData}'s values better use {@link getEq} or {@link getOrd} helpers.
 *
 */
function elem(E) {
    return function (a, fa) { return fa._tag === 'RemoteSuccess' && E.equals(a, fa.value); };
}
exports.elem = elem;
/**
 * Takes a predicate and apply it to {@link RemoteSuccess} value.
 * `Left` part will return `false`.
 */
function exists(p) {
    return function (fa) { return fa._tag === 'RemoteSuccess' && p(fa.value); };
}
exports.exists = exists;
/**
 * Maps this RemoteFailure error into RemoteSuccess if passed function `f` return {@link Some} value, otherwise returns self
 */
function recover(f) {
    var r = recoverMap(f, function_1.identity);
    return function (fa) { return (fa._tag === 'RemoteFailure' ? r(fa) : fa); };
}
exports.recover = recover;
/**
 * Recovers {@link RemoteFailure} also mapping {@link RemoteSuccess} case
 * @see {@link recover}
 */
function recoverMap(f, g) {
    return function (fa) {
        switch (fa._tag) {
            case 'RemoteInitial': {
                return fa;
            }
            case 'RemotePending': {
                return fa;
            }
            case 'RemoteFailure': {
                var b = f(fa.error);
                return b._tag === 'Some' ? exports.success(b.value) : fa;
            }
            case 'RemoteSuccess': {
                return exports.success(g(fa.value));
            }
        }
    };
}
exports.recoverMap = recoverMap;
var concatPendings = function (a, b) {
    if (Option_1.isSome(a.progress) && Option_1.isSome(b.progress)) {
        var progressA = a.progress.value;
        var progressB = b.progress.value;
        if (Option_1.isNone(progressA.total) || Option_1.isNone(progressB.total)) {
            return exports.progress({
                loaded: progressA.loaded + progressB.loaded,
                total: Option_1.none,
            });
        }
        var totalA = progressA.total.value;
        var totalB = progressB.total.value;
        var total = totalA + totalB;
        var loaded = (progressA.loaded * totalA + progressB.loaded * totalB) / (total * total);
        return exports.progress({
            loaded: loaded,
            total: Option_1.some(total),
        });
    }
    var noA = Option_1.isNone(a.progress);
    var noB = Option_1.isNone(b.progress);
    if (noA && !noB) {
        return b;
    }
    if (!noA && noB) {
        return a;
    }
    return exports.pending;
};
//instance
exports.remoteData = {
    //HKT
    URI: exports.URI,
    //Monad
    of: function (value) { return exports.success(value); },
    ap: function (fab, fa) {
        switch (fa._tag) {
            case 'RemoteInitial': {
                return exports.isFailure(fab) ? fab : exports.initial;
            }
            case 'RemotePending': {
                return exports.isPending(fab) ? concatPendings(fa, fab) : exports.isSuccess(fab) ? fa : fab;
            }
            case 'RemoteFailure': {
                return exports.isFailure(fab) ? fab : fa;
            }
            case 'RemoteSuccess': {
                return exports.isSuccess(fab) ? exports.success(fab.value(fa.value)) : fab;
            }
        }
    },
    map: function (fa, f) {
        return exports.isSuccess(fa) ? exports.success(f(fa.value)) : fa;
    },
    chain: function (fa, f) {
        return exports.isSuccess(fa) ? f(fa.value) : fa;
    },
    //Foldable
    reduce: function (fa, b, f) {
        return pipeable_1.pipe(fa, exports.fold(function () { return b; }, function () { return b; }, function () { return b; }, function (a) { return f(b, a); }));
    },
    reduceRight: function (fa, b, f) { return (exports.isSuccess(fa) ? f(fa.value, b) : b); },
    foldMap: function (M) { return function (fa, f) {
        return exports.isSuccess(fa) ? f(fa.value) : M.empty;
    }; },
    //Traversable
    traverse: function (F) { return function (ta, f) {
        if (exports.isSuccess(ta)) {
            return F.map(f(ta.value), function (a) { return exports.remoteData.of(a); });
        }
        else {
            return F.of(ta);
        }
    }; },
    sequence: function (F) { return function (ta) {
        return exports.remoteData.traverse(F)(ta, function_1.identity);
    }; },
    //Bifunctor
    bimap: function (fla, f, g) {
        return pipeable_1.pipe(fla, exports.fold(function () { return exports.initial; }, Option_1.fold(function () { return exports.pending; }, exports.progress), function (e) { return exports.failure(f(e)); }, function (a) { return exports.success(g(a)); }));
    },
    mapLeft: function (fla, f) {
        return exports.fold(function () { return exports.initial; }, Option_1.fold(function () { return exports.pending; }, exports.progress), function (e) { return exports.failure(f(e)); }, function () { return fla; })(fla);
    },
    //Alt
    alt: function (fx, fy) { return exports.fold(fy, fy, fy, function () { return fx; })(fx); },
    //Alternative
    zero: function () { return exports.initial; },
    //Extend
    extend: function (fla, f) {
        return pipeable_1.pipe(fla, exports.fold(function () { return exports.initial; }, Option_1.fold(function () { return exports.pending; }, exports.progress), function () { return fla; }, function () { return exports.success(f(fla)); }));
    },
};
//Eq
exports.getEq = function (EE, EA) {
    return {
        equals: function (x, y) {
            return pipeable_1.pipe(x, exports.fold(function () { return exports.isInitial(y); }, function () { return exports.isPending(y); }, function (xError) {
                return pipeable_1.pipe(y, exports.fold(function_1.constFalse, function_1.constFalse, function (yError) { return EE.equals(xError, yError); }, function_1.constFalse));
            }, function (ax) {
                return pipeable_1.pipe(y, exports.fold(function_1.constFalse, function_1.constFalse, function_1.constFalse, function (ay) { return EA.equals(ax, ay); }));
            }));
        },
    };
};
//Ord
var constLt = function_1.constant(-1);
var constEq = function_1.constant(0);
var constGt = function_1.constant(1);
exports.getOrd = function (OE, OA) {
    return tslib_1.__assign({}, exports.getEq(OE, OA), { compare: function (x, y) {
            return Ordering_1.sign(pipeable_1.pipe(x, exports.fold(function () {
                return pipeable_1.pipe(y, exports.fold(constEq, constLt, constLt, constLt));
            }, function () {
                return pipeable_1.pipe(y, exports.fold(constGt, constEq, constLt, constLt));
            }, function (xError) {
                return pipeable_1.pipe(y, exports.fold(constGt, constGt, function (yError) { return OE.compare(xError, yError); }, constLt));
            }, function (xValue) {
                return pipeable_1.pipe(y, exports.fold(constGt, constGt, constGt, function (yValue) { return OA.compare(xValue, yValue); }));
            })));
        } });
};
//Semigroup
exports.getSemigroup = function (SE, SA) {
    return {
        concat: function (x, y) {
            var constX = function_1.constant(x);
            var constY = function_1.constant(y);
            return pipeable_1.pipe(x, exports.fold(function () {
                return pipeable_1.pipe(y, exports.fold(constY, constY, constY, constY));
            }, function () {
                return pipeable_1.pipe(y, exports.fold(constX, function () { return concatPendings(x, y); }, constY, constY));
            }, function (xError) {
                return pipeable_1.pipe(y, exports.fold(constX, constX, function (yError) { return exports.failure(SE.concat(xError, yError)); }, function () { return y; }));
            }, function (xValue) {
                return pipeable_1.pipe(y, exports.fold(constX, constX, function () { return x; }, function (yValue) { return exports.success(SA.concat(xValue, yValue)); }));
            }));
        },
    };
};
//Monoid
exports.getMonoid = function (SL, SA) {
    return tslib_1.__assign({}, exports.getSemigroup(SL, SA), { empty: exports.initial });
};
var showOptionNumber = Option_1.getShow(Show_1.showNumber);
//Show
exports.getShow = function (SE, SA) { return ({
    show: exports.fold(function () { return 'initial'; }, Option_1.fold(function () { return 'pending'; }, function (progress) {
        return "progress({ loaded: " + Show_1.showNumber.show(progress.loaded) + ", total: " + showOptionNumber.show(progress.total) + " })";
    }), function (e) { return "failure(" + SE.show(e) + ")"; }, function (a) { return "success(" + SA.show(a) + ")"; }),
}); };
var _a = pipeable_1.pipeable(exports.remoteData), alt = _a.alt, ap = _a.ap, apFirst = _a.apFirst, apSecond = _a.apSecond, bimap = _a.bimap, chain = _a.chain, chainFirst = _a.chainFirst, duplicate = _a.duplicate, extend = _a.extend, flatten = _a.flatten, foldMap = _a.foldMap, map = _a.map, mapLeft = _a.mapLeft, reduce = _a.reduce, reduceRight = _a.reduceRight;
exports.alt = alt;
exports.ap = ap;
exports.apFirst = apFirst;
exports.apSecond = apSecond;
exports.bimap = bimap;
exports.chain = chain;
exports.chainFirst = chainFirst;
exports.duplicate = duplicate;
exports.extend = extend;
exports.flatten = flatten;
exports.foldMap = foldMap;
exports.map = map;
exports.mapLeft = mapLeft;
exports.reduce = reduce;
exports.reduceRight = reduceRight;
function combine() {
    var list = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        list[_i] = arguments[_i];
    }
    if (list.length === 0) {
        return exports.remoteData.of([]);
    }
    return Array_1.array.sequence(exports.remoteData)(list);
}
exports.combine = combine;
