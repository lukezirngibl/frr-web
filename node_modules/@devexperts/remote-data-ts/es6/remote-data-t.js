import * as tslib_1 from "tslib";
import { failure, fold, progress, remoteData, success, initial, pending, fromOption, } from './remote-data';
import { getApplicativeComposition, } from 'fp-ts/lib/Applicative';
export function getRemoteDataM(M) {
    var A = getApplicativeComposition(M, remoteData);
    return tslib_1.__assign({}, A, { chain: function (fa, f) { return M.chain(fa, function (a) { return (a._tag === 'RemoteSuccess' ? f(a.value) : M.of(a)); }); }, alt: function (fa, f) { return M.chain(fa, function (a) { return (a._tag === 'RemoteSuccess' ? A.of(a.value) : f()); }); }, bimap: function (fa, f, g) { return M.map(fa, function (a) { return remoteData.bimap(a, f, g); }); }, mapLeft: function (ma, f) { return M.map(ma, function (a) { return remoteData.mapLeft(a, f); }); }, fold: function (ma, onInitial, onPending, onFailure, onSuccess) {
            return M.chain(ma, fold(onInitial, onPending, onFailure, onSuccess));
        }, getOrElse: function (ma, a) { return M.chain(ma, fold(a, a, a, M.of)); }, orElse: function (ma, f) { return M.chain(ma, fold(f, f, f, function (a) { return A.of(a); })); }, initial: M.of(initial), pending: M.of(pending), progress: function (p) { return M.of(progress(p)); }, progressM: function (mp) { return M.map(mp, progress); }, failure: function (e) { return M.of(failure(e)); }, failureM: function (me) { return M.map(me, failure); }, fromM: function (ma) { return M.map(ma, success); }, fromOption: function (a, e) { return M.of(fromOption(a, e)); } });
}
