import { failure, fold, progress, remoteData, success, initial, pending, fromOption, } from './remote-data';
import { getApplicativeComposition, } from 'fp-ts/es6/Applicative';
export function getRemoteDataM(M) {
    const A = getApplicativeComposition(M, remoteData);
    return Object.assign({}, A, { chain: (fa, f) => M.chain(fa, a => (a._tag === 'RemoteSuccess' ? f(a.value) : M.of(a))), alt: (fa, f) => M.chain(fa, a => (a._tag === 'RemoteSuccess' ? A.of(a.value) : f())), bimap: (fa, f, g) => M.map(fa, a => remoteData.bimap(a, f, g)), mapLeft: (ma, f) => M.map(ma, a => remoteData.mapLeft(a, f)), fold: (ma, onInitial, onPending, onFailure, onSuccess) => M.chain(ma, fold(onInitial, onPending, onFailure, onSuccess)), getOrElse: (ma, a) => M.chain(ma, fold(a, a, a, M.of)), orElse: (ma, f) => M.chain(ma, fold(f, f, f, a => A.of(a))), initial: M.of(initial), pending: M.of(pending), progress: p => M.of(progress(p)), progressM: mp => M.map(mp, progress), failure: e => M.of(failure(e)), failureM: me => M.map(me, failure), fromM: ma => M.map(ma, success), fromOption: (a, e) => M.of(fromOption(a, e)) });
}
