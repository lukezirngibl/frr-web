import * as tslib_1 from "tslib";
import { constFalse, identity, constant } from 'fp-ts/lib/function';
import { isNone, isSome, none, some, fold as foldO, getShow as getShowOption } from 'fp-ts/lib/Option';
import { left, right, fold as foldEither } from 'fp-ts/lib/Either';
import { array } from 'fp-ts/lib/Array';
import { sign } from 'fp-ts/lib/Ordering';
import { pipe, pipeable } from 'fp-ts/lib/pipeable';
import { showNumber } from 'fp-ts/lib/Show';
export var URI = 'RemoteData';
//constructors
export var failure = function (error) { return ({
    _tag: 'RemoteFailure',
    error: error,
}); };
export var success = function (value) { return ({
    _tag: 'RemoteSuccess',
    value: value,
}); };
export var pending = {
    _tag: 'RemotePending',
    progress: none,
};
export var progress = function (progress) { return ({
    _tag: 'RemotePending',
    progress: some(progress),
}); };
export var initial = {
    _tag: 'RemoteInitial',
};
//filters
/**
 * Returns true only if {@link RemoteData} is {@link RemoteFailure}
 */
export var isFailure = function (data) { return data._tag === 'RemoteFailure'; };
/**
 * Returns true only if {@link RemoteData} is {@link RemoteSuccess}
 */
export var isSuccess = function (data) { return data._tag === 'RemoteSuccess'; };
/**
 * Returns true only if {@link RemoteData} is {@link RemotePending}
 */
export var isPending = function (data) { return data._tag === 'RemotePending'; };
/**
 * Returns true only if {@link RemoteData} is {@link RemoteInitial}
 */
export var isInitial = function (data) { return data._tag === 'RemoteInitial'; };
/**
 * Takes a default value as an argument.
 * If this {@link RemoteData} is "Left" part it will return default value.
 * If this {@link RemoteData} is {@link RemoteSuccess} it will return it's value ("wrapped" value, not default value)
 *
 * Note: Default value should be the same type as {@link RemoteData} (internal) value, if you want to pass different type as default, use {@link fold}.
 *
 * @example
 * getOrElse(() => 999)(some(1)) // 1
 * getOrElseValue(() => 999)(initial) // 999
 */
export var getOrElse = function (f) { return function (ma) { return (isSuccess(ma) ? ma.value : f()); }; };
/**
 * Needed for "unwrap" value from {@link RemoteData} "container".
 * It applies a function to each case in the data structure.
 *
 * @example
 * const onInitial = "it's initial"
 * const onPending = "it's pending"
 * const onFailure = (err) => "it's failure"
 * const onSuccess = (data) => `${data + 1}`
 * const f = fold(onInitial, onPending, onFailure, onSuccess)
 *
 * f(initial) // "it's initial"
 * f(pending) // "it's pending"
 * f(failure(new Error('error text'))) // "it's failure"
 * f(success(21)) // '22'
 */
export var fold = function (onInitial, onPending, onFailure, onSuccess) { return function (ma) {
    switch (ma._tag) {
        case 'RemoteInitial': {
            return onInitial();
        }
        case 'RemotePending': {
            return onPending(ma.progress);
        }
        case 'RemoteFailure': {
            return onFailure(ma.error);
        }
        case 'RemoteSuccess': {
            return onSuccess(ma.value);
        }
    }
}; };
/**
 * One more way to fold (unwrap) value from {@link RemoteData}.
 * `Left` part will return `null`.
 * {@link RemoteSuccess} will return value.
 *
 * For example:
 *
 * `success(2).toNullable() will return 2`
 *
 * `initial.toNullable() will return null`
 *
 * `pending.toNullable() will return null`
 *
 * `failure(new Error('error text)).toNullable() will return null`
 *
 */
export var toNullable = function (ma) { return (isSuccess(ma) ? ma.value : null); };
export var toUndefined = function (ma) { return (isSuccess(ma) ? ma.value : undefined); };
export function fromOption(option, error) {
    if (isNone(option)) {
        return failure(error());
    }
    else {
        return success(option.value);
    }
}
/**
 * Convert {@link RemoteData} to {@link Option}
 * `Left` part will be converted to {@link None}.
 * {@link RemoteSuccess} will be converted to {@link Some}.
 *
 * @example
 * toOption(success(2)) // some(2)
 * toOption(initial) // none
 * toOption(pending) // none
 * toOption(failure(new Error('error text'))) // none
 */
export function toOption(data) {
    return data._tag === 'RemoteSuccess' ? some(data.value) : none;
}
/**
 * Creates {@link RemoteData} from {@link Either}
 */
export var fromEither = foldEither(failure, success);
/**
 * Convert {@link RemoteData} to `Either`.
 * `Left` part will be converted to `Left<L>`.
 * Since {@link RemoteInitial} and {@link RemotePending} do not have `L` values,
 * you must provide a value of type `L` that will be used to construct
 * the `Left<L>` for those two cases.
 * {@link RemoteSuccess} will be converted to `Right<R>`.
 *
 * @example:
 * const f = toEither(
 * 		() => new Error('Data not fetched'),
 * 		() => new Error('Data is fetching')
 * )
 * f(success(2)) // right(2)
 * f(initial) // right(Error('Data not fetched'))
 * f(pending) // right(Error('Data is fetching'))
 * f(failure(new Error('error text'))) // right(Error('error text'))
 */
export function toEither(onInitial, onPending) {
    return function (data) {
        return pipe(data, fold(function () { return left(onInitial()); }, function () { return left(onPending()); }, left, right));
    };
}
export function fromPredicate(predicate, whenFalse) {
    return function (a) { return (predicate(a) ? success(a) : failure(whenFalse(a))); };
}
/**
 * Create {@link RemoteData} from {@link ProgressEvent}
 * @param event
 */
export function fromProgressEvent(event) {
    return progress({
        loaded: event.loaded,
        total: event.lengthComputable ? some(event.total) : none,
    });
}
/**
 * Compare values and returns `true` if they are identical, otherwise returns `false`.
 * `Left` part will return `false`.
 * {@link RemoteSuccess} will call {@link Eq.equals}.
 *
 * If you want to compare {@link RemoteData}'s values better use {@link getEq} or {@link getOrd} helpers.
 *
 */
export function elem(E) {
    return function (a, fa) { return fa._tag === 'RemoteSuccess' && E.equals(a, fa.value); };
}
/**
 * Takes a predicate and apply it to {@link RemoteSuccess} value.
 * `Left` part will return `false`.
 */
export function exists(p) {
    return function (fa) { return fa._tag === 'RemoteSuccess' && p(fa.value); };
}
/**
 * Maps this RemoteFailure error into RemoteSuccess if passed function `f` return {@link Some} value, otherwise returns self
 */
export function recover(f) {
    var r = recoverMap(f, identity);
    return function (fa) { return (fa._tag === 'RemoteFailure' ? r(fa) : fa); };
}
/**
 * Recovers {@link RemoteFailure} also mapping {@link RemoteSuccess} case
 * @see {@link recover}
 */
export function recoverMap(f, g) {
    return function (fa) {
        switch (fa._tag) {
            case 'RemoteInitial': {
                return fa;
            }
            case 'RemotePending': {
                return fa;
            }
            case 'RemoteFailure': {
                var b = f(fa.error);
                return b._tag === 'Some' ? success(b.value) : fa;
            }
            case 'RemoteSuccess': {
                return success(g(fa.value));
            }
        }
    };
}
var concatPendings = function (a, b) {
    if (isSome(a.progress) && isSome(b.progress)) {
        var progressA = a.progress.value;
        var progressB = b.progress.value;
        if (isNone(progressA.total) || isNone(progressB.total)) {
            return progress({
                loaded: progressA.loaded + progressB.loaded,
                total: none,
            });
        }
        var totalA = progressA.total.value;
        var totalB = progressB.total.value;
        var total = totalA + totalB;
        var loaded = (progressA.loaded * totalA + progressB.loaded * totalB) / (total * total);
        return progress({
            loaded: loaded,
            total: some(total),
        });
    }
    var noA = isNone(a.progress);
    var noB = isNone(b.progress);
    if (noA && !noB) {
        return b;
    }
    if (!noA && noB) {
        return a;
    }
    return pending;
};
//instance
export var remoteData = {
    //HKT
    URI: URI,
    //Monad
    of: function (value) { return success(value); },
    ap: function (fab, fa) {
        switch (fa._tag) {
            case 'RemoteInitial': {
                return isFailure(fab) ? fab : initial;
            }
            case 'RemotePending': {
                return isPending(fab) ? concatPendings(fa, fab) : isSuccess(fab) ? fa : fab;
            }
            case 'RemoteFailure': {
                return isFailure(fab) ? fab : fa;
            }
            case 'RemoteSuccess': {
                return isSuccess(fab) ? success(fab.value(fa.value)) : fab;
            }
        }
    },
    map: function (fa, f) {
        return isSuccess(fa) ? success(f(fa.value)) : fa;
    },
    chain: function (fa, f) {
        return isSuccess(fa) ? f(fa.value) : fa;
    },
    //Foldable
    reduce: function (fa, b, f) {
        return pipe(fa, fold(function () { return b; }, function () { return b; }, function () { return b; }, function (a) { return f(b, a); }));
    },
    reduceRight: function (fa, b, f) { return (isSuccess(fa) ? f(fa.value, b) : b); },
    foldMap: function (M) { return function (fa, f) {
        return isSuccess(fa) ? f(fa.value) : M.empty;
    }; },
    //Traversable
    traverse: function (F) { return function (ta, f) {
        if (isSuccess(ta)) {
            return F.map(f(ta.value), function (a) { return remoteData.of(a); });
        }
        else {
            return F.of(ta);
        }
    }; },
    sequence: function (F) { return function (ta) {
        return remoteData.traverse(F)(ta, identity);
    }; },
    //Bifunctor
    bimap: function (fla, f, g) {
        return pipe(fla, fold(function () { return initial; }, foldO(function () { return pending; }, progress), function (e) { return failure(f(e)); }, function (a) { return success(g(a)); }));
    },
    mapLeft: function (fla, f) {
        return fold(function () { return initial; }, foldO(function () { return pending; }, progress), function (e) { return failure(f(e)); }, function () { return fla; })(fla);
    },
    //Alt
    alt: function (fx, fy) { return fold(fy, fy, fy, function () { return fx; })(fx); },
    //Alternative
    zero: function () { return initial; },
    //Extend
    extend: function (fla, f) {
        return pipe(fla, fold(function () { return initial; }, foldO(function () { return pending; }, progress), function () { return fla; }, function () { return success(f(fla)); }));
    },
};
//Eq
export var getEq = function (EE, EA) {
    return {
        equals: function (x, y) {
            return pipe(x, fold(function () { return isInitial(y); }, function () { return isPending(y); }, function (xError) {
                return pipe(y, fold(constFalse, constFalse, function (yError) { return EE.equals(xError, yError); }, constFalse));
            }, function (ax) {
                return pipe(y, fold(constFalse, constFalse, constFalse, function (ay) { return EA.equals(ax, ay); }));
            }));
        },
    };
};
//Ord
var constLt = constant(-1);
var constEq = constant(0);
var constGt = constant(1);
export var getOrd = function (OE, OA) {
    return tslib_1.__assign({}, getEq(OE, OA), { compare: function (x, y) {
            return sign(pipe(x, fold(function () {
                return pipe(y, fold(constEq, constLt, constLt, constLt));
            }, function () {
                return pipe(y, fold(constGt, constEq, constLt, constLt));
            }, function (xError) {
                return pipe(y, fold(constGt, constGt, function (yError) { return OE.compare(xError, yError); }, constLt));
            }, function (xValue) {
                return pipe(y, fold(constGt, constGt, constGt, function (yValue) { return OA.compare(xValue, yValue); }));
            })));
        } });
};
//Semigroup
export var getSemigroup = function (SE, SA) {
    return {
        concat: function (x, y) {
            var constX = constant(x);
            var constY = constant(y);
            return pipe(x, fold(function () {
                return pipe(y, fold(constY, constY, constY, constY));
            }, function () {
                return pipe(y, fold(constX, function () { return concatPendings(x, y); }, constY, constY));
            }, function (xError) {
                return pipe(y, fold(constX, constX, function (yError) { return failure(SE.concat(xError, yError)); }, function () { return y; }));
            }, function (xValue) {
                return pipe(y, fold(constX, constX, function () { return x; }, function (yValue) { return success(SA.concat(xValue, yValue)); }));
            }));
        },
    };
};
//Monoid
export var getMonoid = function (SL, SA) {
    return tslib_1.__assign({}, getSemigroup(SL, SA), { empty: initial });
};
var showOptionNumber = getShowOption(showNumber);
//Show
export var getShow = function (SE, SA) { return ({
    show: fold(function () { return 'initial'; }, foldO(function () { return 'pending'; }, function (progress) {
        return "progress({ loaded: " + showNumber.show(progress.loaded) + ", total: " + showOptionNumber.show(progress.total) + " })";
    }), function (e) { return "failure(" + SE.show(e) + ")"; }, function (a) { return "success(" + SA.show(a) + ")"; }),
}); };
var _a = pipeable(remoteData), alt = _a.alt, ap = _a.ap, apFirst = _a.apFirst, apSecond = _a.apSecond, bimap = _a.bimap, chain = _a.chain, chainFirst = _a.chainFirst, duplicate = _a.duplicate, extend = _a.extend, flatten = _a.flatten, foldMap = _a.foldMap, map = _a.map, mapLeft = _a.mapLeft, reduce = _a.reduce, reduceRight = _a.reduceRight;
export { alt, ap, apFirst, apSecond, bimap, chain, chainFirst, duplicate, extend, flatten, foldMap, map, mapLeft, reduce, reduceRight, };
export function combine() {
    var list = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        list[_i] = arguments[_i];
    }
    if (list.length === 0) {
        return remoteData.of([]);
    }
    return array.sequence(remoteData)(list);
}
